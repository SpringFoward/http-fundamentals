# HTTP 기본
---
+  __모든 것이 HTTP__
+ __클라이언트 서버 구조__
+ __Stateful,Stateless__
+ __비 연결성(connectionless)__
+ __HTTP 메세지__
---

## 모든 것이 HTTP(HyperText Transfer Protocol) 🌐
현 시대는 거의 모든 것을 HTTP메세지로 전달 할 수 있다.

+ HTML, TEXT
+ IMAGE, 음성, 영상, 파일
+ JSON, XML (API)
+ 거의 모든 형태의 데이터 전송 가능
+ 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

#### HTTP 역사
+ HTTP/ 0.9 1991년 : GET 메서드만 지원, HTTP 헤더 X
+ HTTP/1.0 1996년 : 메서드, 헤더 추가
+ __HTTP/1.1 1997년 : 가장 많이 사용, 우리에게 가장 중요한 버전 (대부분의 기능이 여기서 만들어짐)__ 
+ HTTP/2 2015년 : 성능 개선
+ HTTP/3 진행중 : TCP 대신에 UDP 사용, 성능 개선

#### 기반 프로토콜
+ __TCP__ : HTTP/1.1,HTTP/2
+ __UDP__ : HTTP/3
+ 현재 HTTP/1.1 주로 사용 
 + HTTP/2,HTTP/3 도 점점 증가하는 추세
### HTTP 특징
+  클라이언트 서버 구조
+ 무상태 프로토콜, 비연결성
+ HTTP 메세지
+ 단순함, 확장 가능
---
## 클라이언트 서버 구조 🖥️
클라이언트 서버 구조는 일단 클라이언트가 요청을 보내고 응답이 올 때 까지 계속 기다리다가, 서버에서 클라이언트의 요청을 받고 응답을 보내주면 그 응답을 받고 클라이언트가 동작을 하는 구조이다.![[스크린샷 2024-05-06 152223.png]]
여기에서 우리는 클라이언트와 서버를 분리하는 것이 중요하다.  그리고 서버에는 비즈니스 로직이나, 데이터를 넣어놓고, 클라이언트는 UI와 사용성에 집중한다.  이렇게 사용하면 클라이언트와 서버가 둘다 다른 형식으로 발전 할 수 있다. 이렇게 서로의 역할을 분리하면 서버는 데이터와 비즈니스 로직에 대한 발전을 집중적으로 할 수 있고, 클라이언트의 경우 UI와 사용성에 집중하여 발전 할 수 있다.

---
## Stateful,Stateless  🔄

#### 무상태 프로토콜 (Stateless)
+ 서버가 클라이언트의 상태를 보존하지 않는다.
+ 장점 : 서버의 확장성이 높아진다.(스케일 아웃)
+ 단점 : 클라이언트가 추가로 데이터를 전송해야 함

### Stateful,Stateless 차이 (예시로 확인)
##### 상태유지(Stateful)
+ 고객 : 이 노트북은 얼마인가요?
+ 점원 : 100만원 입니다. (노트북의 상태를 유지)

+ 고객 : 2개 구매하겠습니다.
+ 점원 : 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? (노트북,2개 유지)

+  고객 : 신용카드로 구매하겠습니다.
+ 점원 : 200만원 결제 완료되었습니다. (노트북,2개,신용카드 유지)
__정말 우리 일상 생활 속 대화와 비슷하다. (서버가 클라이언트의 상태를 유지함)__
##### 상태유지(Stateful), 점원이 중간에 바뀔 경우
+ 고객 : 이 노트북은 얼마인가요?
+ 점원A : 100만원 입니다.

+ 고객 : 2개 구매하겠습니다.
+ 점원B : ?? 무엇을 2개 구매하시나요?

+  고객 : 신용카드로 구매하겠습니다.
+ 점원C : ??? 무슨 제품을 몇개 신용카드로 구매하시나요?
이렇듯 점원이 중간에 바뀔 경우 문제가 발생한다. 자 이제 무상태로 넘어가 보자
##### 무상태(Stateless)
+ 고객 : 이 __노트북__ 은 얼마인가요?
+ 점원 : 100만원 입니다. 

+ 고객 : __노트북 2개__ 구매하겠습니다.
+ 점원 : 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요? 

+  고객 : __노트북 2개를 신용카드로__ 구매하겠습니다.
+ 점원 : 200만원 결제 완료되었습니다. 
__이렇듯 무상태의 경우 클라이언트(고객)가  계속 지속적으로 서버(점원)에게 필요한 정보를 추가적으로 제공해서 서버가 바뀌어도 문제가 생기지 않는 방법을 의미한다. 이러면 점원이 바뀌어도 전혀 문제가 되지 않는다.__  

### 정리 

+  __상태유지__ : 중간에 다른 점원으로 바뀌면 안된다.
	 (중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.)
	 만약 상태유지로 서버를 만들면 한 서버하고만 계속 소통을 해야함 바뀌면 에러발생
	 대신 클라이언트는 정보를 조금 덜 주어도 됨
+ __무상태__ : 중간에 다른 점원으로 바뀌어도 상관이 없다.
 + 갑자기 고객이 증가해도 점원을 대거 투입 할 수 있음
 + 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있음
+ 무상태는 서버를 쉽게 바꿀 수 있다. -> __무한한 서버 증설이 가능하게 함__
+ 무상태는 서버를 유동적으로 바꿔가면서 사용할 수 있음
+ 대신 클라이언트는 정보를 서버에 더 주어야함
+ 모든 것을 무상태로 설계 할 수 없는 경우도 존재한다.
---
## 비연결성(connectionless) 🚫
만약 각 클라이언트마다 서버가 연결을 계속 유지하면 어떻게 될까? 클라이언트 1,2,3이 있다고 생각하고 서버는 1개라고 생각해보자. 그러면 서버는 클라이언트가 놀고 있는 시간에도 연결을 계속 유지하면서 서버의 자원을 사용해야하는 불편함이 발생할 것이다.

이럴 때 사용하는 것이 __비연결성__ 이다.
비연결성은 클라이언트와 서버가 요청과 응답이 종료되었으면 TCP/IP 연결을 바로 끊어버리는 것이다. 이러한 비연결성을 이용하면 서버는 연결을 유지할 필요가 없고 최소한의 자원만을 이용하여 서버를 유지할 수 있다.

#### 비 연결성 (장점)
+ HTTP는 기본이 연결을 유지하지 않는 모델이다.
+ 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
+ 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적어진다.
+ 서버의 자원을 효율적으로 사용할 수 있다.
#### 비 연결성 (단점 및 극복 방법)
+ __TCP/IP 연결을 새로 맺어야 함__ : 연결하는데 시간이 추가적으로 사용됨
+ 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수많은 자원이 함께 다운로드 된다.
+ 현재는 HTTP 지속 연결로 문제를 해결한다.
+ HTTP/2,HTTP/3에서 더 많은 최적화가 이루어지고 있다.

HTTP가 초기에선 연결과 응답 종료를 계속 이루어지면서 시간 낭비가 많이 이루어졌다. 그러나 현재에는 HTTP지속 연결을 사용하여 필요한 작업이 전부 종료될 때 까지 연결을 끊지 않고 유지한 뒤에 연결을 종료한다.

---

## HTTP 메세지 💬
HTTP 메세지는 HTTP 요청 메세지와 HTTP 응답 메세지가 있는데, 둘의 구조가 약간 다르다.
#### HTTP 메세지 구조
![[스크린샷 2024-05-06 161412.png]]
HTTP 메세지의 구조는 시작라인, 헤더, 공백라인, 메세지 바디로 나뉘어진다. 여기에서 공백라인은 없어도 되는거 아니냐고 생각할 수 있지만, 꼭필요한 라인이니 참고하자.
##### 요청메세지 구조
![[스크린샷 2024-05-06 161558.png]]
##### 응답 메세지 구조
![[스크린샷 2024-05-06 161609.png]]
일단은 각 라인이 어떻게 생겼는지 어떤 역할을 하는지를 집중하여 보도록 하자.
### 시작라인

+ start-line = __request-line__ / status-line
+ __request-line__ = method SP(공백) request-target SP HTTP-versionn CRLF(엔터)

+ HTTP 메서드 (GET: 조회)
+ 요청 대상 (/search?q=hello)
+ HTTP Version

###### 요청 메세지*
+ 종류 :GET,POST,PUT,DELETE
+ 서버가 수행해야 할 동작 지정
 + GET : 리소스 조회
 + POST : 요청 내역 처리

###### 응답 메세지

+ start-line = request-line / __status-line__
+ __status-line__ = HTTP-version SP status-code SP reason-phrase CRLF

+ HTTP 버전
+ HTTP 상태 코드 : 요청 성공, 실패를 나타냄
 + 200 : 성공 (OK)
 + 400 : 클라이언트 요청 오류
 + 500 : 서버 내부 오류
+ 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글

### HTTP 헤더
+  header-field = field-name ":" OWS field-value OWS (OWS : 띄어 쓰기 허용)
+ ield-name 은 대소문자를 구분하지 않는다.

##### HTTP 헤더 용도
+ HTTP 전송에 필요한 모든 부가 정보를 가지고 있음
+ 표준 헤더가 너무 많음
+ 필요시 임의의 헤더 추가 가능

### HTTP 메세지 바디
+ 실제 전송할 데이터
+ byte로 표현할 수 있는 모든 데이터 전송 가능
---
.